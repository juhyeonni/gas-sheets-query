/**
 * Generate Command Tests
 * 
 * Issue #22
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { mkdirSync, rmSync, writeFileSync, readFileSync, existsSync } from 'fs'
import { join } from 'path'
import { runGenerate, generateIndex } from '../../src/commands/generate.js'

// =============================================================================
// Test Fixtures
// =============================================================================

const TEST_DIR = join(process.cwd(), 'tests', 'fixtures', 'generate-test')
const SCHEMA_PATH = join(TEST_DIR, 'schema.gsq.yaml')
const OUTPUT_DIR = join(TEST_DIR, 'generated')

const VALID_SCHEMA = `
enums:
  Role:
    - USER
    - ADMIN

tables:
  User:
    fields:
      id: number @id
      email: string @unique
      name: string?
      role: Role
  Post:
    fields:
      id: number @id
      title: string
      content: string
      authorId: number
    indexes:
      - [authorId]
`

const EMPTY_SCHEMA = ''

const INVALID_YAML = `
tables:
  User:
    fields
      id: string
`

// =============================================================================
// Test Helpers
// =============================================================================

function setupTestDir(): void {
  if (existsSync(TEST_DIR)) {
    rmSync(TEST_DIR, { recursive: true })
  }
  mkdirSync(TEST_DIR, { recursive: true })
}

function cleanupTestDir(): void {
  if (existsSync(TEST_DIR)) {
    rmSync(TEST_DIR, { recursive: true })
  }
}

function writeSchema(content: string): void {
  writeFileSync(SCHEMA_PATH, content, 'utf-8')
}

// =============================================================================
// Tests
// =============================================================================

describe('generateIndex', () => {
  it('should generate index.ts content with re-exports', () => {
    const result = generateIndex()
    
    expect(result).toContain('// Auto-generated by gsquery - DO NOT EDIT')
    expect(result).toContain("export * from './types'")
    expect(result).toContain("export * from './client'")
  })
})

describe('runGenerate', () => {
  beforeEach(() => {
    setupTestDir()
  })
  
  afterEach(() => {
    cleanupTestDir()
  })
  
  // =========================================================================
  // Success Cases
  // =========================================================================
  
  describe('success cases', () => {
    it('should generate all three files from valid schema', async () => {
      writeSchema(VALID_SCHEMA)
      
      const result = await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      expect(result.success).toBe(true)
      expect(result.files).toContain('types.ts')
      expect(result.files).toContain('client.ts')
      expect(result.files).toContain('index.ts')
      expect(result.errors).toHaveLength(0)
    })
    
    it('should create output directory if it does not exist', async () => {
      writeSchema(VALID_SCHEMA)
      
      expect(existsSync(OUTPUT_DIR)).toBe(false)
      
      await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      expect(existsSync(OUTPUT_DIR)).toBe(true)
    })
    
    it('should generate valid types.ts content', async () => {
      writeSchema(VALID_SCHEMA)
      
      await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      const typesContent = readFileSync(join(OUTPUT_DIR, 'types.ts'), 'utf-8')
      
      expect(typesContent).toContain('// Auto-generated by gsquery - DO NOT EDIT')
      expect(typesContent).toContain("export type Role = 'USER' | 'ADMIN'")
      expect(typesContent).toContain('export interface User {')
      expect(typesContent).toContain('export interface Post {')
    })
    
    it('should generate valid client.ts content', async () => {
      writeSchema(VALID_SCHEMA)
      
      await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      const clientContent = readFileSync(join(OUTPUT_DIR, 'client.ts'), 'utf-8')
      
      expect(clientContent).toContain('// Auto-generated by gsquery - DO NOT EDIT')
      expect(clientContent).toContain("import { createSheetsDB")
      expect(clientContent).toContain('export type Tables = {')
      expect(clientContent).toContain('export const schema = {')
      expect(clientContent).toContain('export function createDB')
      expect(clientContent).toContain('export function createTestDB')
    })
    
    it('should generate valid index.ts content', async () => {
      writeSchema(VALID_SCHEMA)
      
      await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      const indexContent = readFileSync(join(OUTPUT_DIR, 'index.ts'), 'utf-8')
      
      expect(indexContent).toContain("export * from './types'")
      expect(indexContent).toContain("export * from './client'")
    })
    
    it('should handle empty schema', async () => {
      writeSchema(EMPTY_SCHEMA)
      
      const result = await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      expect(result.success).toBe(true)
      expect(result.files).toHaveLength(3)
    })
  })
  
  // =========================================================================
  // Error Cases
  // =========================================================================
  
  describe('error cases', () => {
    it('should fail when schema file does not exist', async () => {
      const result = await runGenerate({
        schema: join(TEST_DIR, 'nonexistent.yaml'),
        output: OUTPUT_DIR,
      })
      
      expect(result.success).toBe(false)
      expect(result.errors[0]).toContain('Schema file not found')
    })
    
    it('should fail when schema has invalid YAML', async () => {
      writeSchema(INVALID_YAML)
      
      const result = await runGenerate({
        schema: SCHEMA_PATH,
        output: OUTPUT_DIR,
      })
      
      expect(result.success).toBe(false)
      expect(result.errors[0]).toContain('YAML parse error')
    })
  })
  
  // =========================================================================
  // Options
  // =========================================================================
  
  describe('options', () => {
    it('should use provided schema path', async () => {
      const customPath = join(TEST_DIR, 'custom-schema.yaml')
      writeFileSync(customPath, VALID_SCHEMA, 'utf-8')
      
      const result = await runGenerate({
        schema: customPath,
        output: OUTPUT_DIR,
      })
      
      expect(result.success).toBe(true)
    })
    
    it('should use provided output directory', async () => {
      writeSchema(VALID_SCHEMA)
      const customOutput = join(TEST_DIR, 'custom-output')
      
      await runGenerate({
        schema: SCHEMA_PATH,
        output: customOutput,
      })
      
      expect(existsSync(join(customOutput, 'types.ts'))).toBe(true)
      expect(existsSync(join(customOutput, 'client.ts'))).toBe(true)
      expect(existsSync(join(customOutput, 'index.ts'))).toBe(true)
    })
  })
})
