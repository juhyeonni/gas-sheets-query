/**
 * Types Generator Tests
 * 
 * Issue #20
 */

import { describe, it, expect } from 'vitest'
import { generateTypes } from '../../src/generator/types-generator.js'
import type { SchemaAST } from '../../src/parser/types.js'

describe('generateTypes', () => {
  // =========================================================================
  // Header
  // =========================================================================
  
  describe('header', () => {
    it('should include auto-generated warning comment', () => {
      const ast: SchemaAST = { enums: {}, tables: {} }
      const result = generateTypes(ast)
      
      expect(result).toContain('// Auto-generated by gsquery - DO NOT EDIT')
    })
    
    it('should produce valid output for empty schema', () => {
      const ast: SchemaAST = { enums: {}, tables: {} }
      const result = generateTypes(ast)
      
      expect(result).toContain('// Auto-generated by gsquery - DO NOT EDIT')
      expect(result.trim().length).toBeGreaterThan(0)
    })
  })
  
  // =========================================================================
  // Enum Generation
  // =========================================================================
  
  describe('enum generation', () => {
    it('should generate union type for single-value enum', () => {
      const ast: SchemaAST = {
        enums: {
          Status: { name: 'Status', values: ['ACTIVE'] }
        },
        tables: {}
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain("export type Status = 'ACTIVE'")
    })
    
    it('should generate union type for multi-value enum', () => {
      const ast: SchemaAST = {
        enums: {
          Role: { name: 'Role', values: ['USER', 'ADMIN', 'MODERATOR'] }
        },
        tables: {}
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain("export type Role = 'USER' | 'ADMIN' | 'MODERATOR'")
    })
    
    it('should generate multiple enums', () => {
      const ast: SchemaAST = {
        enums: {
          Role: { name: 'Role', values: ['USER', 'ADMIN'] },
          Status: { name: 'Status', values: ['ACTIVE', 'INACTIVE'] }
        },
        tables: {}
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain("export type Role = 'USER' | 'ADMIN'")
      expect(result).toContain("export type Status = 'ACTIVE' | 'INACTIVE'")
    })
  })
  
  // =========================================================================
  // Interface Generation
  // =========================================================================
  
  describe('interface generation', () => {
    it('should generate interface for simple table', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [] },
              { name: 'name', type: 'string', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('export interface User {')
      expect(result).toContain('id: string')
      expect(result).toContain('name: string')
      expect(result).toContain('}')
    })
    
    it('should handle number type', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          Product: {
            name: 'Product',
            fields: [
              { name: 'price', type: 'number', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('price: number')
    })
    
    it('should handle boolean type', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'isActive', type: 'boolean', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('isActive: boolean')
    })
    
    it('should map datetime to Date', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'createdAt', type: 'datetime', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('createdAt: Date')
    })
  })
  
  // =========================================================================
  // Optional Fields
  // =========================================================================
  
  describe('optional fields', () => {
    it('should use ? for optional fields', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'nickname', type: 'string', optional: true, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('nickname?: string')
    })
    
    it('should handle mixed optional and required fields', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [] },
              { name: 'bio', type: 'string', optional: true, attributes: [] },
              { name: 'age', type: 'number', optional: true, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('id: string')
      expect(result).toContain('bio?: string')
      expect(result).toContain('age?: number')
    })
  })
  
  // =========================================================================
  // Enum Reference in Fields
  // =========================================================================
  
  describe('enum reference in fields', () => {
    it('should use enum name as type', () => {
      const ast: SchemaAST = {
        enums: {
          Role: { name: 'Role', values: ['USER', 'ADMIN'] }
        },
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'role', type: 'Role', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('role: Role')
    })
    
    it('should handle optional enum field', () => {
      const ast: SchemaAST = {
        enums: {
          Status: { name: 'Status', values: ['ACTIVE', 'INACTIVE'] }
        },
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'status', type: 'Status', optional: true, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      expect(result).toContain('status?: Status')
    })
  })
  
  // =========================================================================
  // Array Types
  // =========================================================================

  describe('array types', () => {
    it('should handle string[] type', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          Note: {
            name: 'Note',
            fields: [
              { name: 'tags', type: 'string[]', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain('tags: string[]')
    })

    it('should handle number[] type', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          Data: {
            name: 'Data',
            fields: [
              { name: 'values', type: 'number[]', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain('values: number[]')
    })

    it('should handle optional array types', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          Task: {
            name: 'Task',
            fields: [
              { name: 'labels', type: 'string[]', optional: true, attributes: [] },
              { name: 'scores', type: 'number[]', optional: true, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain('labels?: string[]')
      expect(result).toContain('scores?: number[]')
    })
  })

  // =========================================================================
  // Integration Tests
  // =========================================================================

  describe('integration', () => {
    it('should generate complete output with enums and tables', () => {
      const ast: SchemaAST = {
        enums: {
          Role: { name: 'Role', values: ['USER', 'ADMIN'] },
          Status: { name: 'Status', values: ['ACTIVE', 'INACTIVE', 'PENDING'] }
        },
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [] },
              { name: 'email', type: 'string', optional: false, attributes: [] },
              { name: 'name', type: 'string', optional: true, attributes: [] },
              { name: 'role', type: 'Role', optional: false, attributes: [] },
              { name: 'status', type: 'Status', optional: false, attributes: [] },
              { name: 'createdAt', type: 'datetime', optional: false, attributes: [] }
            ],
            blockAttributes: []
          },
          Post: {
            name: 'Post',
            fields: [
              { name: 'id', type: 'number', optional: false, attributes: [] },
              { name: 'title', type: 'string', optional: false, attributes: [] },
              { name: 'published', type: 'boolean', optional: false, attributes: [] },
              { name: 'authorId', type: 'string', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }
      
      const result = generateTypes(ast)
      
      // Header
      expect(result).toContain('// Auto-generated by gsquery - DO NOT EDIT')
      
      // Enums
      expect(result).toContain("export type Role = 'USER' | 'ADMIN'")
      expect(result).toContain("export type Status = 'ACTIVE' | 'INACTIVE' | 'PENDING'")
      
      // User interface
      expect(result).toContain('export interface User {')
      expect(result).toContain('id: string')
      expect(result).toContain('email: string')
      expect(result).toContain('name?: string')
      expect(result).toContain('role: Role')
      expect(result).toContain('status: Status')
      expect(result).toContain('createdAt: Date')
      
      // Post interface
      expect(result).toContain('export interface Post {')
      expect(result).toContain('id: number')
      expect(result).toContain('title: string')
      expect(result).toContain('published: boolean')
      expect(result).toContain('authorId: string')
    })
    
    it('should output enums before interfaces', () => {
      const ast: SchemaAST = {
        enums: {
          Role: { name: 'Role', values: ['USER', 'ADMIN'] }
        },
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'role', type: 'Role', optional: false, attributes: [] }
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      const enumIndex = result.indexOf('export type Role')
      const interfaceIndex = result.indexOf('export interface User')

      expect(enumIndex).toBeLessThan(interfaceIndex)
    })
  })

  // =========================================================================
  // @relation Type Aliases (Issue #76)
  // =========================================================================

  describe('@relation type aliases', () => {
    it('should generate type alias for relation target', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          Task: {
            name: 'Task',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'assigneeId', type: 'string', optional: true, attributes: [{ name: 'relation', args: ['User'] }] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain("export type UserId = User['id']")
    })

    it('should replace field type with relation alias', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          Task: {
            name: 'Task',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'assigneeId', type: 'string', optional: true, attributes: [{ name: 'relation', args: ['User'] }] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain('assigneeId?: UserId')
    })

    it('should handle array relation field (UserId[])', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          Team: {
            name: 'Team',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'memberIds', type: 'string[]', optional: false, attributes: [{ name: 'relation', args: ['User'] }] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain('memberIds: UserId[]')
    })

    it('should not generate duplicate aliases for same target', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          Task: {
            name: 'Task',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'assigneeId', type: 'string', optional: true, attributes: [{ name: 'relation', args: ['User'] }] },
              { name: 'creatorId', type: 'string', optional: false, attributes: [{ name: 'relation', args: ['User'] }] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      // Should appear exactly once
      const matches = result.match(/export type UserId/g)
      expect(matches).toHaveLength(1)
    })

    it('should generate multiple aliases sorted alphabetically', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          Project: {
            name: 'Project',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          Task: {
            name: 'Task',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'projectId', type: 'string', optional: false, attributes: [{ name: 'relation', args: ['Project'] }] },
              { name: 'assigneeId', type: 'string', optional: true, attributes: [{ name: 'relation', args: ['User'] }] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).toContain("export type ProjectId = Project['id']")
      expect(result).toContain("export type UserId = User['id']")

      const projectIdx = result.indexOf('export type ProjectId')
      const userIdx = result.indexOf('export type UserId')
      expect(projectIdx).toBeLessThan(userIdx)
    })

    it('should place aliases between enums and interfaces', () => {
      const ast: SchemaAST = {
        enums: {
          Status: { name: 'Status', values: ['OPEN', 'DONE'] }
        },
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
            ],
            blockAttributes: []
          },
          Task: {
            name: 'Task',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'assigneeId', type: 'string', optional: false, attributes: [{ name: 'relation', args: ['User'] }] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      const enumIdx = result.indexOf('export type Status')
      const aliasIdx = result.indexOf('export type UserId')
      const interfaceIdx = result.indexOf('export interface')

      expect(enumIdx).toBeLessThan(aliasIdx)
      expect(aliasIdx).toBeLessThan(interfaceIdx)
    })

    it('should not generate aliases when no @relation exists', () => {
      const ast: SchemaAST = {
        enums: {},
        tables: {
          User: {
            name: 'User',
            fields: [
              { name: 'id', type: 'string', optional: false, attributes: [{ name: 'id', args: [] }] },
              { name: 'name', type: 'string', optional: false, attributes: [] },
            ],
            blockAttributes: []
          }
        }
      }

      const result = generateTypes(ast)

      expect(result).not.toContain("['id']")
    })
  })
})
