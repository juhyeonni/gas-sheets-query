/**
 * Generate command - generates types and client from schema
 * 
 * Issue #22, #23 (watch mode)
 */

import { Command } from 'commander'
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs'
import { resolve, dirname, basename } from 'path'
import { watch } from 'chokidar'
import { parseSchema } from '../parser/schema-parser.js'
import { generateTypes } from '../generator/types-generator.js'
import { generateClient } from '../generator/client-generator.js'

// =============================================================================
// Types
// =============================================================================

export interface GenerateOptions {
  schema: string
  output: string
  watch?: boolean
}

export interface GenerateResult {
  success: boolean
  files: string[]
  errors: string[]
}

// =============================================================================
// Index Generator
// =============================================================================

/**
 * Generate index.ts that re-exports types and client
 */
export function generateIndex(): string {
  const lines = [
    '// Auto-generated by gsquery - DO NOT EDIT',
    '',
    "export * from './types'",
    "export * from './client'",
  ]
  return lines.join('\n')
}

// =============================================================================
// File Operations
// =============================================================================

/**
 * Ensure directory exists
 */
function ensureDir(dirPath: string): void {
  if (!existsSync(dirPath)) {
    mkdirSync(dirPath, { recursive: true })
  }
}

/**
 * Write file with directory creation
 */
function writeFile(filePath: string, content: string): void {
  ensureDir(dirname(filePath))
  writeFileSync(filePath, content, 'utf-8')
}

// =============================================================================
// Generate Logic
// =============================================================================

/**
 * Run the generate command
 */
export async function runGenerate(options: GenerateOptions): Promise<GenerateResult> {
  const errors: string[] = []
  const files: string[] = []
  
  // Resolve paths
  const schemaPath = resolve(process.cwd(), options.schema)
  const outputDir = resolve(process.cwd(), options.output)
  
  // Check schema file exists
  if (!existsSync(schemaPath)) {
    return {
      success: false,
      files: [],
      errors: [`Schema file not found: ${schemaPath}`],
    }
  }
  
  // Read schema file
  let schemaContent: string
  try {
    schemaContent = readFileSync(schemaPath, 'utf-8')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files: [],
      errors: [`Failed to read schema file: ${error.message}`],
    }
  }
  
  // Parse schema
  const parseResult = parseSchema(schemaContent)
  
  if (!parseResult.success || !parseResult.schema) {
    return {
      success: false,
      files: [],
      errors: parseResult.errors.map(e => e.message),
    }
  }
  
  // Collect parse warnings
  if (parseResult.errors.length > 0) {
    for (const err of parseResult.errors) {
      errors.push(`Warning: ${err.message}`)
    }
  }
  
  const schema = parseResult.schema
  
  // Generate types
  try {
    const typesContent = generateTypes(schema)
    const typesPath = resolve(outputDir, 'types.ts')
    writeFile(typesPath, typesContent)
    files.push('types.ts')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files,
      errors: [...errors, `Failed to generate types: ${error.message}`],
    }
  }
  
  // Generate client
  try {
    const clientContent = generateClient(schema)
    const clientPath = resolve(outputDir, 'client.ts')
    writeFile(clientPath, clientContent)
    files.push('client.ts')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files,
      errors: [...errors, `Failed to generate client: ${error.message}`],
    }
  }
  
  // Generate index
  try {
    const indexContent = generateIndex()
    const indexPath = resolve(outputDir, 'index.ts')
    writeFile(indexPath, indexContent)
    files.push('index.ts')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files,
      errors: [...errors, `Failed to generate index: ${error.message}`],
    }
  }
  
  return {
    success: true,
    files,
    errors,
  }
}

// =============================================================================
// Utilities
// =============================================================================

/**
 * Format current time as [HH:MM:SS]
 */
function formatTimestamp(): string {
  const now = new Date()
  const hours = String(now.getHours()).padStart(2, '0')
  const minutes = String(now.getMinutes()).padStart(2, '0')
  const seconds = String(now.getSeconds()).padStart(2, '0')
  return `[${hours}:${minutes}:${seconds}]`
}

/**
 * Run generate and print results (used by both initial run and watch)
 */
async function runAndPrint(options: GenerateOptions): Promise<boolean> {
  const result = await runGenerate(options)
  
  if (!result.success) {
    console.error('‚ùå Generation failed:')
    for (const error of result.errors) {
      console.error(`   ${error}`)
    }
    return false
  }
  
  // Show warnings if any
  const warnings = result.errors.filter(e => e.startsWith('Warning:'))
  if (warnings.length > 0) {
    console.log('‚ö†Ô∏è  Warnings:')
    for (const warning of warnings) {
      console.log(`   ${warning}`)
    }
  }
  
  console.log(`‚úÖ Generated ${result.files.join(', ')}`)
  return true
}

/**
 * Start watching schema file for changes
 */
async function startWatch(options: GenerateOptions): Promise<void> {
  const schemaPath = resolve(process.cwd(), options.schema)
  const schemaName = basename(schemaPath)
  
  console.log('üëÄ Watching for changes...')
  console.log('')
  
  const watcher = watch(schemaPath, {
    persistent: true,
    ignoreInitial: true,
  })
  
  // Debounce to avoid multiple rapid triggers
  let debounceTimer: NodeJS.Timeout | null = null
  
  watcher.on('change', () => {
    if (debounceTimer) {
      clearTimeout(debounceTimer)
    }
    
    debounceTimer = setTimeout(async () => {
      const startTime = performance.now()
      console.log(`${formatTimestamp()} ${schemaName} changed`)
      
      try {
        const success = await runAndPrint(options)
        const elapsed = Math.round(performance.now() - startTime)
        
        if (success) {
          console.log(`   Regenerated in ${elapsed}ms`)
        }
      } catch (err) {
        const error = err as Error
        console.error(`‚ùå Error: ${error.message}`)
      }
      console.log('')
    }, 100) // 100ms debounce
  })
  
  watcher.on('error', (err: unknown) => {
    const error = err instanceof Error ? err : new Error(String(err))
    console.error(`‚ùå Watcher error: ${error.message}`)
  })
  
  // Handle Ctrl+C gracefully
  const cleanup = () => {
    console.log('')
    console.log('üëã Stopping watch mode...')
    watcher.close()
    process.exit(0)
  }
  
  process.on('SIGINT', cleanup)
  process.on('SIGTERM', cleanup)
  
  // Keep process alive
  await new Promise(() => {})
}

// =============================================================================
// CLI Command
// =============================================================================

export const generateCommand = new Command('generate')
  .description('Generate types and client from schema')
  .option('-s, --schema <path>', 'Schema file path', 'schema.gsq.yaml')
  .option('-o, --output <path>', 'Output directory', 'generated')
  .option('-w, --watch', 'Watch schema file for changes and regenerate')
  .action(async (options: GenerateOptions) => {
    console.log('üîß Generating from schema...')
    console.log(`   Schema: ${options.schema}`)
    console.log(`   Output: ${options.output}`)
    console.log('')
    
    // Initial generation
    const success = await runAndPrint(options)
    
    if (!success && !options.watch) {
      process.exit(1)
    }
    
    // Watch mode
    if (options.watch) {
      console.log('')
      await startWatch(options)
    } else {
      console.log('')
      console.log('üéâ Done!')
    }
  })
