/**
 * Generate command - generates types and client from schema
 * 
 * Issue #22
 */

import { Command } from 'commander'
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs'
import { resolve, dirname } from 'path'
import { parseSchema } from '../parser/schema-parser.js'
import { generateTypes } from '../generator/types-generator.js'
import { generateClient } from '../generator/client-generator.js'

// =============================================================================
// Types
// =============================================================================

export interface GenerateOptions {
  schema: string
  output: string
  watch?: boolean
}

export interface GenerateResult {
  success: boolean
  files: string[]
  errors: string[]
}

// =============================================================================
// Index Generator
// =============================================================================

/**
 * Generate index.ts that re-exports types and client
 */
export function generateIndex(): string {
  const lines = [
    '// Auto-generated by gsq - DO NOT EDIT',
    '',
    "export * from './types'",
    "export * from './client'",
  ]
  return lines.join('\n')
}

// =============================================================================
// File Operations
// =============================================================================

/**
 * Ensure directory exists
 */
function ensureDir(dirPath: string): void {
  if (!existsSync(dirPath)) {
    mkdirSync(dirPath, { recursive: true })
  }
}

/**
 * Write file with directory creation
 */
function writeFile(filePath: string, content: string): void {
  ensureDir(dirname(filePath))
  writeFileSync(filePath, content, 'utf-8')
}

// =============================================================================
// Generate Logic
// =============================================================================

/**
 * Run the generate command
 */
export async function runGenerate(options: GenerateOptions): Promise<GenerateResult> {
  const errors: string[] = []
  const files: string[] = []
  
  // Resolve paths
  const schemaPath = resolve(process.cwd(), options.schema)
  const outputDir = resolve(process.cwd(), options.output)
  
  // Check schema file exists
  if (!existsSync(schemaPath)) {
    return {
      success: false,
      files: [],
      errors: [`Schema file not found: ${schemaPath}`],
    }
  }
  
  // Read schema file
  let schemaContent: string
  try {
    schemaContent = readFileSync(schemaPath, 'utf-8')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files: [],
      errors: [`Failed to read schema file: ${error.message}`],
    }
  }
  
  // Parse schema
  const parseResult = parseSchema(schemaContent)
  
  if (!parseResult.success || !parseResult.schema) {
    return {
      success: false,
      files: [],
      errors: parseResult.errors.map(e => e.message),
    }
  }
  
  // Collect parse warnings
  if (parseResult.errors.length > 0) {
    for (const err of parseResult.errors) {
      errors.push(`Warning: ${err.message}`)
    }
  }
  
  const schema = parseResult.schema
  
  // Generate types
  try {
    const typesContent = generateTypes(schema)
    const typesPath = resolve(outputDir, 'types.ts')
    writeFile(typesPath, typesContent)
    files.push('types.ts')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files,
      errors: [...errors, `Failed to generate types: ${error.message}`],
    }
  }
  
  // Generate client
  try {
    const clientContent = generateClient(schema)
    const clientPath = resolve(outputDir, 'client.ts')
    writeFile(clientPath, clientContent)
    files.push('client.ts')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files,
      errors: [...errors, `Failed to generate client: ${error.message}`],
    }
  }
  
  // Generate index
  try {
    const indexContent = generateIndex()
    const indexPath = resolve(outputDir, 'index.ts')
    writeFile(indexPath, indexContent)
    files.push('index.ts')
  } catch (err) {
    const error = err as Error
    return {
      success: false,
      files,
      errors: [...errors, `Failed to generate index: ${error.message}`],
    }
  }
  
  return {
    success: true,
    files,
    errors,
  }
}

// =============================================================================
// CLI Command
// =============================================================================

export const generateCommand = new Command('generate')
  .description('Generate types and client from schema')
  .option('-s, --schema <path>', 'Schema file path', 'schema.gsq.yaml')
  .option('-o, --output <path>', 'Output directory', 'generated')
  .option('-w, --watch', 'Watch for changes (not implemented yet)')
  .action(async (options: GenerateOptions) => {
    // Watch mode reminder
    if (options.watch) {
      console.log('‚ö†Ô∏è  Watch mode will be implemented in #23')
      console.log('')
    }
    
    console.log('üîß Generating from schema...')
    console.log(`   Schema: ${options.schema}`)
    console.log(`   Output: ${options.output}`)
    console.log('')
    
    const result = await runGenerate(options)
    
    if (!result.success) {
      console.error('‚ùå Generation failed:')
      for (const error of result.errors) {
        console.error(`   ${error}`)
      }
      process.exit(1)
    }
    
    // Show warnings if any
    const warnings = result.errors.filter(e => e.startsWith('Warning:'))
    if (warnings.length > 0) {
      console.log('‚ö†Ô∏è  Warnings:')
      for (const warning of warnings) {
        console.log(`   ${warning}`)
      }
      console.log('')
    }
    
    console.log('‚úÖ Generated files:')
    for (const file of result.files) {
      console.log(`   ${options.output}/${file}`)
    }
    console.log('')
    console.log('üéâ Done!')
  })
