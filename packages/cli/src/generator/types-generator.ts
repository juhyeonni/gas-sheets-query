/**
 * Types Generator - generates TypeScript types from AST
 *
 * Issue #20
 */

import type { SchemaAST, EnumAST, TableAST, FieldAST } from '../parser/types.js'
import { escapeStringLiteral } from '../utils/sanitize.js'
import { mapType } from './type-mapping.js'

// =============================================================================
// Constants
// =============================================================================

const HEADER = '// Auto-generated by gsquery - DO NOT EDIT'

// =============================================================================
// Relation Helpers
// =============================================================================

/**
 * Collect unique relation targets from all tables, sorted alphabetically.
 * Returns array of target table names (e.g., ['Project', 'User']).
 */
export function collectRelationTargets(ast: SchemaAST): string[] {
  const targets = new Set<string>()
  for (const table of Object.values(ast.tables)) {
    for (const field of table.fields) {
      const relationAttr = field.attributes.find(a => a.name === 'relation')
      if (relationAttr && typeof relationAttr.args[0] === 'string') {
        targets.add(relationAttr.args[0])
      }
    }
  }
  return [...targets].sort()
}

/**
 * Generate type alias line for a relation target.
 *
 * @example
 * "export type UserId = User['id']"
 */
function generateRelationAlias(target: string): string {
  return `export type ${target}Id = ${target}['id']`
}

/**
 * Get the relation alias type name for a field, if it has @relation.
 * Returns null if the field has no @relation attribute.
 */
function getRelationType(field: FieldAST): string | null {
  const relationAttr = field.attributes.find(a => a.name === 'relation')
  if (!relationAttr || typeof relationAttr.args[0] !== 'string') return null
  const target = relationAttr.args[0]
  const alias = `${target}Id`
  if (field.type === 'string[]') return `${alias}[]`
  return alias
}

// =============================================================================
// Enum Generation
// =============================================================================

/**
 * Generate TypeScript union type for an enum
 *
 * @example
 * export type Role = 'USER' | 'ADMIN'
 */
function generateEnum(enumAst: EnumAST): string {
  const values = enumAst.values.map(v => `'${escapeStringLiteral(v)}'`).join(' | ')
  return `export type ${enumAst.name} = ${values}`
}

// =============================================================================
// Interface Generation
// =============================================================================

/**
 * Generate a single field line
 *
 * @example
 * "  name: string"
 * "  nickname?: string"
 * "  assigneeId?: UserId"
 */
function generateField(field: FieldAST): string {
  const optionalMark = field.optional ? '?' : ''
  const relationType = getRelationType(field)
  const tsType = relationType ?? mapType(field.type)
  return `  ${field.name}${optionalMark}: ${tsType}`
}

/**
 * Generate TypeScript interface for a table
 *
 * @example
 * export interface User {
 *   id: string
 *   name: string
 * }
 */
function generateInterface(table: TableAST): string {
  const fields = table.fields.map(generateField).join('\n')
  return `export interface ${table.name} {\n${fields}\n}`
}

// =============================================================================
// Main Entry Point
// =============================================================================

/**
 * Generate TypeScript types from schema AST
 */
export function generateTypes(ast: SchemaAST): string {
  const lines: string[] = []

  // Header
  lines.push(HEADER)
  lines.push('')

  // Enums (before interfaces so they can be referenced)
  const enumNames = Object.keys(ast.enums).sort()
  for (const name of enumNames) {
    lines.push(generateEnum(ast.enums[name]))
  }

  // Relation type aliases (between enums and interfaces)
  const relationTargets = collectRelationTargets(ast)
  if (relationTargets.length > 0) {
    if (enumNames.length > 0) {
      lines.push('')
    }
    for (const target of relationTargets) {
      lines.push(generateRelationAlias(target))
    }
  }

  // Add spacing before interfaces
  const hasContentAbove = enumNames.length > 0 || relationTargets.length > 0
  if (hasContentAbove && Object.keys(ast.tables).length > 0) {
    lines.push('')
  }

  // Interfaces
  const tableNames = Object.keys(ast.tables).sort()
  for (let i = 0; i < tableNames.length; i++) {
    if (i > 0) lines.push('')
    lines.push(generateInterface(ast.tables[tableNames[i]]))
  }

  return lines.join('\n') + '\n'
}
